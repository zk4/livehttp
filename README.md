# intro
suppose you want to make a comand line tool called stare.
it accept integer as numbers
ouput carrots we need to feed
```
ex:
	cmd> stare 2 
	ouput: 4
```

we can get the output by two ways:
- command line
	```bash
	 stare  2
	```

- call python moudle 
  ``` bash
  python -m stare 2
  ```



# best practice schema 
##  env 
Generated by `make env`

This is first step you need to do in any python project
- it will create a virtual env
- auto source it 
- install requirements for the start up

## test 
run `make test`


## run
`make run ` will run in module mode 
`make main` will run in normal mode


You can see that `main.py` and `stare/__main__.py` are the same  content file.

why do we need `main.py` ? 
It is eay to make an  entry in IDE , like intellij.


Could I just use `__main__.py` to run  like this?
``` bash
python stare/__main__.py
```
You cound not.

That is because the top-level package problem.

Ex:
```
python main.py 
top-level package is the same as main.py

python src/func/main.py  
top-level package is the same as main.py, aka func 
top-level package is the folder where you run this command from
```

So , why `stare/__main__.py` does not work?

because top-level package is stare now.


## logging 
  Always use logging for log print,don`t use `print`
  logging config is controlled by `logging.yml`, which can control every module level
  call `setup_logging` in main file (ra)

## make module
  update readmeput moudle in the folder parallel with logx folder.

  - logx 
  - your_module


## packing module or cmd

###  local 
for quick test purpose
- install: `pip install .` 
- uninstall: `pip uninstall <module_name>`

> make install
> make uninstall


### upload to test or prod PYPI server 
upload to test server:
```
make upload-to-test 
```

upload to prod server:
```
make upload-to-prod
```

### test and coverage 

#### pure test
```
make test
```

#### test with coverage
```
make coverage
```



